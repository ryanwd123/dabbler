INFO:pygls.server:Starting IO server
DEBUG:pygls.server:Content length: 5868
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 5868\r\n\r\n{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":2820,"clientInfo":{"name":"Visual Studio Code","version":"1.88.0"},"locale":"en","rootPath":"c:\\\\Users\\\\ryanw\\\\python_projects\\\\dabbler\\\\dabbler","rootUri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional","normalizesLineEndings":true,"changeAnnotationSupport":{"groupsOnLabel":true}},"configuration":true,"didChangeWatchedFiles":{"dynamicRegistration":true,"relativePatternSupport":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"tagSupport":{"valueSet":[1]},"resolveSupport":{"properties":["location.range"]}},"codeLens":{"refreshSupport":true},"executeCommand":{"dynamicRegistration":true},"didChangeConfiguration":{"dynamicRegistration":true},"workspaceFolders":true,"semanticTokens":{"refreshSupport":true},"fileOperations":{"dynamicRegistration":true,"didCreate":true,"didRename":true,"didDelete":true,"willCreate":true,"willRename":true,"willDelete":true},"inlineValue":{"refreshSupport":true},"inlayHint":{"refreshSupport":true},"diagnostics":{"refreshSupport":true}},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]},"codeDescriptionSupport":true,"dataSupport":true},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]},"insertReplaceSupport":true,"resolveSupport":{"properties":["documentation","detail","additionalTextEdits"]},"insertTextModeSupport":{"valueSet":[1,2]},"labelDetailsSupport":true},"insertTextMode":2,"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},"completionList":{"itemDefaults":["commitCharacters","editRange","insertTextFormat","insertTextMode"]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true},"activeParameterSupport":true},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true,"tagSupport":{"valueSet":[1]},"labelSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"disabledSupport":true,"dataSupport":true,"resolveSupport":{"properties":["edit"]},"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}},"honorsChangeAnnotations":false},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true,"prepareSupportDefaultBehavior":1,"honorsChangeAnnotations":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true,"foldingRangeKind":{"valueSet":["comment","imports","region"]},"foldingRange":{"collapsedText":false}},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true},"callHierarchy":{"dynamicRegistration":true},"semanticTokens":{"dynamicRegistration":true,"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","decorator"],"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"formats":["relative"],"requests":{"range":true,"full":{"delta":true}},"multilineTokenSupport":false,"overlappingTokenSupport":false,"serverCancelSupport":true,"augmentsSyntaxTokens":true},"linkedEditingRange":{"dynamicRegistration":true},"typeHierarchy":{"dynamicRegistration":true},"inlineValue":{"dynamicRegistration":true},"inlayHint":{"dynamicRegistration":true,"resolveSupport":{"properties":["tooltip","textEdits","label.tooltip","label.location","label.command"]}},"diagnostic":{"dynamicRegistration":true,"relatedDocumentSupport":false}},"window":{"showMessage":{"messageActionItem":{"additionalPropertiesSupport":true}},"showDocument":{"support":true},"workDoneProgress":true},"general":{"staleRequestSupport":{"cancel":true,"retryOnContentModified":["textDocument/semanticTokens/full","textDocument/semanticTokens/range","textDocument/semanticTokens/full/delta"]},"regularExpressions":{"engine":"ECMAScript","version":"ES2020"},"markdown":{"parser":"marked","version":"1.1.0"},"positionEncodings":["utf-16"]},"notebookDocument":{"synchronization":{"dynamicRegistration":true,"executionSummarySupport":true}}},"trace":"off","workspaceFolders":[{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler","name":"dabbler"}]}}'
DEBUG:pygls.protocol.json_rpc:Request message received.
INFO:pygls.protocol.language_server:Language server initialized InitializeParams(capabilities=ClientCapabilities(workspace=WorkspaceClientCapabilities(apply_edit=True, workspace_edit=WorkspaceEditClientCapabilities(document_changes=True, resource_operations=[<ResourceOperationKind.Create: 'create'>, <ResourceOperationKind.Rename: 'rename'>, <ResourceOperationKind.Delete: 'delete'>], failure_handling=<FailureHandlingKind.TextOnlyTransactional: 'textOnlyTransactional'>, normalizes_line_endings=True, change_annotation_support=WorkspaceEditClientCapabilitiesChangeAnnotationSupportType(groups_on_label=True)), did_change_configuration=DidChangeConfigurationClientCapabilities(dynamic_registration=True), did_change_watched_files=DidChangeWatchedFilesClientCapabilities(dynamic_registration=True, relative_pattern_support=True), symbol=WorkspaceSymbolClientCapabilities(dynamic_registration=True, symbol_kind=WorkspaceSymbolClientCapabilitiesSymbolKindType(value_set=[<SymbolKind.File: 1>, <SymbolKind.Module: 2>, <SymbolKind.Namespace: 3>, <SymbolKind.Package: 4>, <SymbolKind.Class: 5>, <SymbolKind.Method: 6>, <SymbolKind.Property: 7>, <SymbolKind.Field: 8>, <SymbolKind.Constructor: 9>, <SymbolKind.Enum: 10>, <SymbolKind.Interface: 11>, <SymbolKind.Function: 12>, <SymbolKind.Variable: 13>, <SymbolKind.Constant: 14>, <SymbolKind.String: 15>, <SymbolKind.Number: 16>, <SymbolKind.Boolean: 17>, <SymbolKind.Array: 18>, <SymbolKind.Object: 19>, <SymbolKind.Key: 20>, <SymbolKind.Null: 21>, <SymbolKind.EnumMember: 22>, <SymbolKind.Struct: 23>, <SymbolKind.Event: 24>, <SymbolKind.Operator: 25>, <SymbolKind.TypeParameter: 26>]), tag_support=WorkspaceSymbolClientCapabilitiesTagSupportType(value_set=[<SymbolTag.Deprecated: 1>]), resolve_support=WorkspaceSymbolClientCapabilitiesResolveSupportType(properties=['location.range'])), execute_command=ExecuteCommandClientCapabilities(dynamic_registration=True), workspace_folders=True, configuration=True, semantic_tokens=SemanticTokensWorkspaceClientCapabilities(refresh_support=True), code_lens=CodeLensWorkspaceClientCapabilities(refresh_support=True), file_operations=FileOperationClientCapabilities(dynamic_registration=True, did_create=True, will_create=True, did_rename=True, will_rename=True, did_delete=True, will_delete=True), inline_value=InlineValueWorkspaceClientCapabilities(refresh_support=True), inlay_hint=InlayHintWorkspaceClientCapabilities(refresh_support=True), diagnostics=DiagnosticWorkspaceClientCapabilities(refresh_support=True), folding_range=None), text_document=TextDocumentClientCapabilities(synchronization=TextDocumentSyncClientCapabilities(dynamic_registration=True, will_save=True, will_save_wait_until=True, did_save=True), completion=CompletionClientCapabilities(dynamic_registration=True, completion_item=CompletionClientCapabilitiesCompletionItemType(snippet_support=True, commit_characters_support=True, documentation_format=[<MarkupKind.Markdown: 'markdown'>, <MarkupKind.PlainText: 'plaintext'>], deprecated_support=True, preselect_support=True, tag_support=CompletionClientCapabilitiesCompletionItemTypeTagSupportType(value_set=[<CompletionItemTag.Deprecated: 1>]), insert_replace_support=True, resolve_support=CompletionClientCapabilitiesCompletionItemTypeResolveSupportType(properties=['documentation', 'detail', 'additionalTextEdits']), insert_text_mode_support=CompletionClientCapabilitiesCompletionItemTypeInsertTextModeSupportType(value_set=[<InsertTextMode.AsIs: 1>, <InsertTextMode.AdjustIndentation: 2>]), label_details_support=True), completion_item_kind=CompletionClientCapabilitiesCompletionItemKindType(value_set=[<CompletionItemKind.Text: 1>, <CompletionItemKind.Method: 2>, <CompletionItemKind.Function: 3>, <CompletionItemKind.Constructor: 4>, <CompletionItemKind.Field: 5>, <CompletionItemKind.Variable: 6>, <CompletionItemKind.Class: 7>, <CompletionItemKind.Interface: 8>, <CompletionItemKind.Module: 9>, <CompletionItemKind.Property: 10>, <CompletionItemKind.Unit: 11>, <CompletionItemKind.Value: 12>, <CompletionItemKind.Enum: 13>, <CompletionItemKind.Keyword: 14>, <CompletionItemKind.Snippet: 15>, <CompletionItemKind.Color: 16>, <CompletionItemKind.File: 17>, <CompletionItemKind.Reference: 18>, <CompletionItemKind.Folder: 19>, <CompletionItemKind.EnumMember: 20>, <CompletionItemKind.Constant: 21>, <CompletionItemKind.Struct: 22>, <CompletionItemKind.Event: 23>, <CompletionItemKind.Operator: 24>, <CompletionItemKind.TypeParameter: 25>]), insert_text_mode=<InsertTextMode.AdjustIndentation: 2>, context_support=True, completion_list=CompletionClientCapabilitiesCompletionListType(item_defaults=['commitCharacters', 'editRange', 'insertTextFormat', 'insertTextMode'])), hover=HoverClientCapabilities(dynamic_registration=True, content_format=[<MarkupKind.Markdown: 'markdown'>, <MarkupKind.PlainText: 'plaintext'>]), signature_help=SignatureHelpClientCapabilities(dynamic_registration=True, signature_information=SignatureHelpClientCapabilitiesSignatureInformationType(documentation_format=[<MarkupKind.Markdown: 'markdown'>, <MarkupKind.PlainText: 'plaintext'>], parameter_information=SignatureHelpClientCapabilitiesSignatureInformationTypeParameterInformationType(label_offset_support=True), active_parameter_support=True), context_support=True), declaration=DeclarationClientCapabilities(dynamic_registration=True, link_support=True), definition=DefinitionClientCapabilities(dynamic_registration=True, link_support=True), type_definition=TypeDefinitionClientCapabilities(dynamic_registration=True, link_support=True), implementation=ImplementationClientCapabilities(dynamic_registration=True, link_support=True), references=ReferenceClientCapabilities(dynamic_registration=True), document_highlight=DocumentHighlightClientCapabilities(dynamic_registration=True), document_symbol=DocumentSymbolClientCapabilities(dynamic_registration=True, symbol_kind=DocumentSymbolClientCapabilitiesSymbolKindType(value_set=[<SymbolKind.File: 1>, <SymbolKind.Module: 2>, <SymbolKind.Namespace: 3>, <SymbolKind.Package: 4>, <SymbolKind.Class: 5>, <SymbolKind.Method: 6>, <SymbolKind.Property: 7>, <SymbolKind.Field: 8>, <SymbolKind.Constructor: 9>, <SymbolKind.Enum: 10>, <SymbolKind.Interface: 11>, <SymbolKind.Function: 12>, <SymbolKind.Variable: 13>, <SymbolKind.Constant: 14>, <SymbolKind.String: 15>, <SymbolKind.Number: 16>, <SymbolKind.Boolean: 17>, <SymbolKind.Array: 18>, <SymbolKind.Object: 19>, <SymbolKind.Key: 20>, <SymbolKind.Null: 21>, <SymbolKind.EnumMember: 22>, <SymbolKind.Struct: 23>, <SymbolKind.Event: 24>, <SymbolKind.Operator: 25>, <SymbolKind.TypeParameter: 26>]), hierarchical_document_symbol_support=True, tag_support=DocumentSymbolClientCapabilitiesTagSupportType(value_set=[<SymbolTag.Deprecated: 1>]), label_support=True), code_action=CodeActionClientCapabilities(dynamic_registration=True, code_action_literal_support=CodeActionClientCapabilitiesCodeActionLiteralSupportType(code_action_kind=CodeActionClientCapabilitiesCodeActionLiteralSupportTypeCodeActionKindType(value_set=['', 'quickfix', 'refactor', 'refactor.extract', 'refactor.inline', 'refactor.rewrite', 'source', 'source.organizeImports'])), is_preferred_support=True, disabled_support=True, data_support=True, resolve_support=CodeActionClientCapabilitiesResolveSupportType(properties=['edit']), honors_change_annotations=False), code_lens=CodeLensClientCapabilities(dynamic_registration=True), document_link=DocumentLinkClientCapabilities(dynamic_registration=True, tooltip_support=True), color_provider=DocumentColorClientCapabilities(dynamic_registration=True), formatting=DocumentFormattingClientCapabilities(dynamic_registration=True), range_formatting=DocumentRangeFormattingClientCapabilities(dynamic_registration=True, ranges_support=None), on_type_formatting=DocumentOnTypeFormattingClientCapabilities(dynamic_registration=True), rename=RenameClientCapabilities(dynamic_registration=True, prepare_support=True, prepare_support_default_behavior=<PrepareSupportDefaultBehavior.Identifier: 1>, honors_change_annotations=True), folding_range=FoldingRangeClientCapabilities(dynamic_registration=True, range_limit=5000, line_folding_only=True, folding_range_kind=FoldingRangeClientCapabilitiesFoldingRangeKindType(value_set=['comment', 'imports', 'region']), folding_range=FoldingRangeClientCapabilitiesFoldingRangeType(collapsed_text=False)), selection_range=SelectionRangeClientCapabilities(dynamic_registration=True), publish_diagnostics=PublishDiagnosticsClientCapabilities(related_information=True, tag_support=PublishDiagnosticsClientCapabilitiesTagSupportType(value_set=[<DiagnosticTag.Unnecessary: 1>, <DiagnosticTag.Deprecated: 2>]), version_support=False, code_description_support=True, data_support=True), call_hierarchy=CallHierarchyClientCapabilities(dynamic_registration=True), semantic_tokens=SemanticTokensClientCapabilities(requests=SemanticTokensClientCapabilitiesRequestsType(range=True, full=SemanticTokensClientCapabilitiesRequestsTypeFullType1(delta=True)), token_types=['namespace', 'type', 'class', 'enum', 'interface', 'struct', 'typeParameter', 'parameter', 'variable', 'property', 'enumMember', 'event', 'function', 'method', 'macro', 'keyword', 'modifier', 'comment', 'string', 'number', 'regexp', 'operator', 'decorator'], token_modifiers=['declaration', 'definition', 'readonly', 'static', 'deprecated', 'abstract', 'async', 'modification', 'documentation', 'defaultLibrary'], formats=[<TokenFormat.Relative: 'relative'>], dynamic_registration=True, overlapping_token_support=False, multiline_token_support=False, server_cancel_support=True, augments_syntax_tokens=True), linked_editing_range=LinkedEditingRangeClientCapabilities(dynamic_registration=True), moniker=None, type_hierarchy=TypeHierarchyClientCapabilities(dynamic_registration=True), inline_value=InlineValueClientCapabilities(dynamic_registration=True), inlay_hint=InlayHintClientCapabilities(dynamic_registration=True, resolve_support=InlayHintClientCapabilitiesResolveSupportType(properties=['tooltip', 'textEdits', 'label.tooltip', 'label.location', 'label.command'])), diagnostic=DiagnosticClientCapabilities(dynamic_registration=True, related_document_support=False), inline_completion=None), notebook_document=NotebookDocumentClientCapabilities(synchronization=NotebookDocumentSyncClientCapabilities(dynamic_registration=True, execution_summary_support=True)), window=WindowClientCapabilities(work_done_progress=True, show_message=ShowMessageRequestClientCapabilities(message_action_item=ShowMessageRequestClientCapabilitiesMessageActionItemType(additional_properties_support=True)), show_document=ShowDocumentClientCapabilities(support=True)), general=GeneralClientCapabilities(stale_request_support=GeneralClientCapabilitiesStaleRequestSupportType(cancel=True, retry_on_content_modified=['textDocument/semanticTokens/full', 'textDocument/semanticTokens/range', 'textDocument/semanticTokens/full/delta']), regular_expressions=RegularExpressionsClientCapabilities(engine='ECMAScript', version='ES2020'), markdown=MarkdownClientCapabilities(parser='marked', version='1.1.0', allowed_tags=None), position_encodings=['utf-16']), experimental=None), process_id=2820, client_info=InitializeParamsClientInfoType(name='Visual Studio Code', version='1.88.0'), locale='en', root_path='c:\\Users\\ryanw\\python_projects\\dabbler\\dabbler', root_uri='file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler', initialization_options=None, trace=<TraceValues.Off: 'off'>, work_done_token=None, workspace_folders=[WorkspaceFolder(uri='file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler', name='dabbler')])
DEBUG:pygls.protocol.language_server:Server capabilities: {"positionEncoding": "utf-16", "textDocumentSync": {"openClose": true, "change": 2, "willSave": false, "willSaveWaitUntil": false, "save": false}, "completionProvider": {"triggerCharacters": [":", ".", "/", " "]}, "executeCommandProvider": {"commands": ["sendSqlToDbDabbler", "dbDabblerFormatCurrentStatement"]}, "workspace": {"workspaceFolders": {"supported": true, "changeNotifications": true}, "fileOperations": {}}}
INFO:pygls.protocol.json_rpc:Sending data: {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"positionEncoding": "utf-16", "textDocumentSync": {"openClose": true, "change": 2, "willSave": false, "willSaveWaitUntil": false, "save": false}, "completionProvider": {"triggerCharacters": [":", ".", "/", " "]}, "executeCommandProvider": {"commands": ["sendSqlToDbDabbler", "dbDabblerFormatCurrentStatement"]}, "workspace": {"workspaceFolders": {"supported": true, "changeNotifications": true}, "fileOperations": {}}}, "serverInfo": {"name": "pygls-json-example", "version": "v0.1"}}}
DEBUG:pygls.server:Content length: 52
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 52\r\n\r\n{"jsonrpc":"2.0","method":"initialized","params":{}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.server:Content length: 1311
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 1311\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py","languageId":"python","version":848,"text":"#%%\\r\\nimport duckdb\\r\\ndb = duckdb.connect()\\r\\n#!%load_ext dabbler.ext\\r\\n#%%\\r\\n# %%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE SCHEMA _SYS_BIC;\\r\\nCREATE TABLE _SYS_BIC.\\"finance.labor/actuals_cost_script\\"(\\r\\n    ALKJDSD VARCHAR(10));\\r\\nCREATE TABLE _SYS_BIC.tst123(\\r\\n    ALKJDSD VARCHAR)\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE SCHEMA abc;\\r\\nCREATE TABLE abc.\\"finance.labor/actuals_cost_script\\"(\\r\\n    ALKJDSD VARCHAR)\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n# %%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nselect\\r\\n    t.schema_name, t.table_name\\r\\nfrom duckdb_tables t\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nselect\\r\\n    t.ALKJDSD,\\r\\n    t.ALKJDSD\\r\\nfrom _SYS_BIC.\\"finance.labor/actuals_cost_script\\" t\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n#%%\\r\\nfrom dabbler.lsp.db_data import make_db, make_completion_map\\r\\nfrom dabbler.db_stuff import get_db_data_new\\r\\n\\r\\n\\r\\ndbd = get_db_data_new(db)\\r\\n\\r\\ndb2 = make_db(dbd)\\r\\n\\r\\ncomp_map = make_completion_map(db2, dbd)\\r\\n\\r\\n# %%\\r\\ncomp_map[\'_SYS_BIC\']\\r\\n\'_SYS_BIC\' in comp_map[\'root_namespace\']\\r\\n\\r\\n\\r\\n[k for k in comp_map.keys() if \'BIC\' in k]"}}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:dabbler_lsp:key_file {'c:\\Users\\ryanw\\python_projects\\sql_editor': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\sql_editor', 'main_port': 50415, 'handshake_port': 50429, 'server_id': 20841752743661003958279623757821163509, 'client_id': 289039153013225664027765632288045294448}, 'c:\\Users\\ryanw\\python_projects\\qt_plot_test': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\qt_plot_test', 'main_port': 51530, 'handshake_port': 51544, 'server_id': 146518401247648623216606185621065584985, 'client_id': 140988247832029580575691958158698820269}, 'c:\\Users\\ryanw\\python_projects\\qt_data_viz': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\qt_data_viz', 'main_port': 58332, 'handshake_port': 58346, 'server_id': 140587584459631244392314133660810534720, 'client_id': 285692505785895291964299363118935991531}, 'c:\\Users\\ryanw\\python_projects\\file_search': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\file_search', 'main_port': 52980, 'handshake_port': 52994, 'server_id': 335290134155232771256352042037172168343, 'client_id': 260587681759914210952717460315976447844}, 'c:\\Users\\ryanw\\python_projects\\pyside_charts': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\pyside_charts', 'main_port': 52634, 'handshake_port': 52648, 'server_id': 214501652212443245871954900245267983155, 'client_id': 221401047884938047671233825120543528544}, 'c:\\Users\\ryanw\\python_projects\\dabbler\\dabbler': {'workspace_path': 'c:\\Users\\ryanw\\python_projects\\dabbler\\dabbler', 'main_port': 60141, 'handshake_port': 60153, 'server_id': 230697069291926810492573880219161025422, 'client_id': 155356087340673846261419481295800596930}}
DEBUG:pygls.server:Content length: 11991
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 11991\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/tst_load_ext2.py","languageId":"python","version":1,"text":"#%%\\r\\nimport sys\\r\\nfrom pathlib import Path\\r\\nimport pandas as pd\\r\\nsys.path.append(str(Path(__file__).parent.parent))\\r\\nimport duckdb\\r\\ndb = duckdb.connect()\\r\\n# db.execute(\\"set file_search_path to \'C:\\\\\\\\scripts\'\\")\\r\\n###!%load_ext dabbler.ext_debug\\r\\n#!%load_ext dabbler.ext\\r\\n\\r\\ndf1 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\n\\r\\nfiles =  list(Path(\'./../../sample_data/austin\').glob(\\"*.csv\\"))\\r\\nf = files[0]\\r\\nfor f in files:\\r\\n    t_name = f\'{f.name}\'.replace(\'.csv\',\'\').replace(\'-\',\'\')\\r\\n    db.sql(\\r\\n        f\\"\\"\\"--sql\\r\\n        create or replace table {t_name} as\\r\\n        select * from read_csv_auto(\'{f}\',header=true)\\r\\n        \\"\\"\\")\\r\\n\\r\\nfiles =  list(Path(\'./../../sample_data\').glob(\\"*.csv\\"))\\r\\nf = files[0]\\r\\nfor f in files:\\r\\n    t_name = f\'{f.name}\'.replace(\'.csv\',\'\').replace(\'-\',\'\')\\r\\n    db.sql(\\r\\n        f\\"\\"\\"--sql\\r\\n        create or replace table {t_name} as\\r\\n        select * from read_csv_auto(\'{f}\',header=true)\\r\\n        \\"\\"\\")\\r\\ndb.execute(\\"force checkpoint\\")\\r\\n\\r\\n#%%\\r\\ndf7898 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nselect\\r\\n    *\\r\\nfrom sasdf\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    with aaa as (\\r\\n        SELECT\\r\\n            i.CROWN_REMOVAL,\\r\\n            i.ENCROACHMENT_OF_ROOT_ZONE,\\r\\n            i.JURISDICTION,\\r\\n            i.SPECIES\\r\\n        from Issued_Tree_Permits i\\r\\n        WHERE\\r\\n            i.ENCROACHMENT_OF_ROOT_ZONE = true\\r\\n    ),\\r\\n    ggg as (SELECT\\r\\n        z.* EXCLUDE (CROWN_REMOVAL)\\r\\n    from aaa z\\r\\n    ),\\r\\n    xyz as (select \\r\\n        *\\r\\n    from Issued_Tree_Permits i\\r\\n        join ggg g on g.SPECIES = i.SPECIES\\r\\n    ), t123 as (\\r\\n    select \\r\\n        CASE \\r\\n            when j.PERMIT_ADDRESS ILIKE \'%grover%\' then \'grover\'\\r\\n            when j.PERMIT_ADDRESS ILIKE \'%gor%\' then \'grover\'\\r\\n            when j.PERMIT_ADDRESS ILIKE \'%oak%\' then \'grover\'\\r\\n            else \'not grover\'\\r\\n        END as j7,\\r\\n        j.*\\r\\n    from xyz j\\r\\n    WHERE j.ISSUED_DATE > \'2020-01-01\'\\r\\n    ),\\r\\n    t1234 as (\\r\\n    SELECT\\r\\n        t.j7,\\r\\n        t.JURISDICTION,\\r\\n        t.Combined_Geo,\\r\\n        t.TRUNK_DIAMETER,\\r\\n        t.PERMIT_STATUS,\\r\\n        t.APPENDIX_F_REMOVED,\\r\\n        t.PERMIT_CLASS,\\r\\n        t.APPENDIX_F_REMOVED,\\r\\n        t.PROJECT_ID,\\r\\n        t.PERMIT_NUMBER,\\r\\n    from t123 t\\r\\n    ), g0a9s8d as (pivot t1234 on j7 using max(TRUNK_DIAMETER))\\r\\n    from ggg\\r\\n    SELECT *\\r\\n\\r\\n        \\r\\n        \\r\\n\\r\\n\\r\\n\\r\\n    \\"\\"\\"\\r\\n)\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE SCHEMA v;\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE TABLE v.t1(\\r\\n    a INTEGER,\\r\\n)\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n\\r\\n#%%\\r\\n\\r\\ndb.execute(\\"force checkpoint\\")\\r\\n\\r\\nimport duckdb\\r\\ndb = duckdb.connect()\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    CREATE or REPLACE TABLE t1 as\\r\\n    from (VALUES\\r\\n        (\'a\',1),\\r\\n        (\'b\',2),\\r\\n        (\'c\',3),\\r\\n        (\'d\',4),\\r\\n        (\'e\',5),\\r\\n        (NULL,6),\\r\\n        ) as a(c1,c2);\\r\\n    \\r\\n    CREATE OR REPLACE TABLE t2 as\\r\\n    from (VALUES\\r\\n        (\'a\',1),\\r\\n        (\'b\',2),\\r\\n        (\'c\',3),\\r\\n        (\'j\',4),\\r\\n        ) as a(c1,c2);\\r\\n    \\r\\n    from t2 t\\r\\n    SELECT t.c1\\r\\n    WHERE t.c1 not in (SELECT DISTINCT c1 from t1)\\r\\n        \\r\\n    \\"\\"\\"\\r\\n)\\r\\n#%%)\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE SCHEMA v;\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE TABLE v.t1(\\r\\n    a INTEGER,\\r\\n)\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nCREATE macro v.t3() as TABLE select \'abc\';\\r\\nCREATE macro v.t2() as \'abc\';\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nSELECT \\r\\n    i.PERMIT_NUMBER,\\r\\n    i.*\\r\\n\\r\\nfrom Issued_Tree_Permits i\\r\\nWHERE i.PERMIT_STATUS in (\'Approved with Conditions\')\\r\\nor i.COUNCIL_DISTRICT = 1\\r\\n\\r\\n\\"\\"\\"\\r\\n)\\r\\n#%%\\r\\n\\r\\ndf77 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nselect\\r\\n    database_name||\'.\'||schema_name as db_scm,\\r\\n    function_name,\\r\\n    function_type,\\r\\nfrom duckdb_functions()\\r\\nWHERE internal = false\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n#%%\\r\\n\\r\\n\\r\\n#%%\\r\\nfrom dabbler.lsp.db_data import make_db, make_completion_map\\r\\nfrom dabbler.db_stuff import get_db_data_new\\r\\n\\r\\n\\r\\ndbd = get_db_data_new(db)\\r\\n\\r\\ndb2 = make_db(dbd)\\r\\n\\r\\ncomp_map = make_completion_map(db2, dbd)\\r\\n\\r\\ndbd[\'functions\']\\r\\n\\r\\n#%%\\r\\n\\r\\nfor i in range(10):\\r\\n    exec(f\\"\\"\\"df7{i} = pd.DataFrame({{\'a\':[1,2+{i},3],\'b\':[4,5,6]}})\\"\\"\\")\\r\\n\\r\\ndb.sql(\\r\\n\\"\\"\\"--sql,\\r\\nselect\\r\\n    *\\r\\nfrom df70, df7, df71, df75, df78\\r\\n\\"\\"\\"\\r\\n)\\r\\n\\r\\n#%%\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    from Issued_Tree_Permits i\\r\\n    SELECT \\r\\n        CASE lower(i.PERMIT_STATUS) \\r\\n            WHEN \'approved\' THEN \'a\' \\r\\n            ELSE \\r\\n                CASE i.PERMIT_ADDRESS\\r\\n                    WHEN \'g\' THEN \'c\' \\r\\n                    ELSE i.PERMIT_STATUS \\r\\n                END \\r\\n        END as a,\\r\\n        i.COUNCIL_DISTRICT as b,\\r\\n        \\r\\n        \\r\\n    \\"\\"\\"\\r\\n)\\r\\n\\r\\n\\r\\n\\r\\n#%%\\r\\nimport logging\\r\\nlog = logging.getLogger(\'test\')\\r\\ntxt = \\"\\"\\"--sql\\r\\n\\r\\n    \\r\\n    \\"\\"\\"\\r\\nfrom dabbler.lsp.parser import interactive_parse\\r\\nfind_txt = \'a as j w\'\\r\\npos = txt.find(find_txt)+len(find_txt)\\r\\ntxt.find(find_txt)\\r\\ntxt[:pos]\\r\\n\\r\\ninteractive_parse(txt,pos,log)\\r\\n\\r\\n\\r\\n#%%\\r\\n\\r\\ndb.execute(\\"force checkpoint\\")\\r\\n\\r\\ndb.execute(\\"\\"\\"--sql\\r\\n    FORCE CHECKPOINT;\\r\\n    DROP VIEW if EXISTS my_view2;\\r\\n    DROP TABLE if EXISTS my_table2;\\r\\n    CREATE OR REPLACE TABLE my_table (\\r\\n        id INTEGER PRIMARY KEY,\\r\\n        wbs VARCHAR UNIQUE,\\r\\n        amt DOUBLE,\\r\\n        description VARCHAR,\\r\\n        gen GENERATED ALWAYS AS (1),\\r\\n        CHECK(amt > 0),\\r\\n    ) ;\\r\\n    INSERT INTO my_table VALUES (1, \'wbs1\', 1.9, \'abc\'), (2, \'wbs2\', 2.9, \'def\');\\r\\n    SELECT * FROM my_table;\\r\\n    CREATE or REPLACE VIEW my_view AS (SELECT * from my_table);\\r\\n    SELECT v.description, v.amt FROM my_view v;\\r\\n    ALTER VIEW my_view RENAME TO my_view2;\\r\\n    CREATE OR REPLACE SEQUENCE my_seq;\\r\\n    CREATE or REPLACE TABLE imdb.main.my_tb (\\r\\n        id INTEGER,\\r\\n        name VARCHAR,\\r\\n    );\\r\\n    CREATE SCHEMA IF NOT EXISTS my_schema;\\r\\n    ALTER TABLE my_table RENAME TO my_table2;\\r\\n    ALTER TABLE my_table2 RENAME id to id2;\\r\\n    ALTER TABLE imdb.main.my_tb ALTER COLUMN id TYPE VARCHAR;\\r\\n    CHECKPOINT;\\r\\n    CHECKPOINT imdb;\\r\\n    SELECT * from Issued_Tree_Permits;\\r\\n\\r\\n    \\r\\n    \\"\\"\\")\\r\\n\\r\\n#%%\\r\\ndb.sql(\\"\\"\\"--sql\\r\\n    select * from medicare USING SAMPLE 2\\r\\n    \\r\\n    \\"\\"\\")\\r\\n#%%\\r\\ndb.execute(\\"\\"\\"--sql\\r\\n    create table t_test as select * from \'txtb.csv\';\\r\\n    \\r\\n    \\"\\"\\")\\r\\n\\r\\n#%%\\r\\n\\r\\ntxt = \\"\\"\\"--sql\\r\\n    \\r\\n\\r\\n    \\r\\n    \\"\\"\\"\\r\\ndb.sql(txt)\\r\\n\\r\\n#%%\\r\\nfrom dabbler.lsp.parser import interactive_parse\\r\\nfind_txt = \'abc s\'\\r\\npos = txt.find(find_txt)+len(find_txt)\\r\\ntxt.find(find_txt)\\r\\ntxt[:pos]\\r\\n\\r\\ninteractive_parse(txt,pos,log)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n#%%\\r\\n\\r\\n#%%\\r\\nglobals()[\'__vsc_ipynb_file__\']\\r\\n\\r\\n#%%\\r\\n\\r\\nimport os\\r\\nos.chdir(r\'C:\\\\scripts\')\\r\\n\\r\\ndf9 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\ndf10 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    from read_csv_auto(\'./rates.csv\',header=true,normalize_names=true) z\\r\\n    select z.oh_ce\\r\\n    \\"\\"\\")\\r\\n#%%\\r\\nfrom urllib.parse import urlparse, unquote\\r\\nuri = \'file:///c%3A/Projects/db_dabbler/src/test_files/tst_load_ext2.py\'\\r\\n\\r\\nunquote(uri)\\r\\n\\r\\n\\r\\npath = Path(unquote(uri[8:]))\\r\\npath.is_file()\\r\\n\\r\\nimport pprint\\r\\npprint.pprint(globals())\\r\\n\\r\\n#%%\\r\\ndb.sql(\\"show tables\\")\\r\\nsql_txt = (\\r\\n     \\"\\"\\"--sql\\r\\n    with cine as (select distinct\\r\\n        c.person_id,\\r\\n        p.name,\\r\\n        c.category,\\r\\n        c.title_id,\\r\\n        t.primary_title,\\r\\n        r.averageRating,\\r\\n        r.numVotes\\r\\n    from imdb.main.crew c\\r\\n        join imdb.main.people p on p.person_id = c.person_id\\r\\n        join imdb.main.titles t on t.title_id = c.title_id\\r\\n        join imdb.main.akas a on a.title_id = t.title_id\\r\\n        join imdb.main.ratings r on r.tconst = t.title_id\\r\\n    where\\r\\n        t.type = \'movie\'\\r\\n        --and a.region = \'US\'\\r\\n        and c.category = \'cinematographer\'\\r\\n    --group by all\\r\\n    --order by title_count desc\\r\\n    ), cc as (\\r\\n    select \\r\\n        c.person_id,\\r\\n        c.name,\\r\\n        c.category,\\r\\n        c.person_id, c.numVotes,\\r\\n        c.person_id,\\r\\n        count() as title_count,\\r\\n        sum(c.numVotes) as total_votes,\\r\\n        avg(c.averageRating) as avg_rating\\r\\n        \\r\\n    from cine c\\r\\n    group by all\\r\\n    order by title_count desc)\\r\\n    select\\r\\n        k.numVotes,\\r\\n        sum(k.averageRating),\\r\\n        k.averageRating,\\r\\n    from cine k \\r\\n    \\"\\"\\")\\r\\n\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    with qq as (from athlete_events select *),\\r\\n    qq2 as (from qq select *),\\r\\n    qq3 as (from qq2 select * exclude (Age, Sex, ID, Height))\\r\\n    from qq3 q select q.City, q.Medal, q.NOC\\r\\n    \\"\\"\\")\\r\\n\\r\\n#%%\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    with crew_count as (\\r\\n        from imdb.main.crew c\\r\\n        select\\r\\n            c.title_id,\\r\\n            count() as crew_count\\r\\n        group by all\\r\\n    ),\\r\\n    prin_count as (\\r\\n        from imdb.main.principals p\\r\\n        select\\r\\n            p.tconst as title_id,\\r\\n            count() as prin_count\\r\\n        group by all\\r\\n    ),\\r\\n    t_count as (\\r\\n        select * from crew_count\\r\\n        union all\\r\\n        select * from prin_count\\r\\n    )\\r\\n    from imdb.main.titles t\\r\\n        join imdb.main.ratings r on r.tconst = t.title_id\\r\\n        join crew_count c on c.title_id = t.title_id\\r\\n        join prin_count p on p.title_id = t.title_id    \\r\\n    select\\r\\n        t.title_id,\\r\\n        t.primary_title,\\r\\n        r.averageRating,\\r\\n        r.numVotes,\\r\\n        c.crew_count,\\r\\n        c.crew_count,\\r\\n        p.prin_count,\\r\\n        c.crew_count + p.prin_count as total_count\\r\\n    order by r.numVotes desc\\r\\n    \\r\\n    \\"\\"\\")\\r\\n#%%\\r\\ndb.execute(\\"set file_search_path to \'C:\\\\\\\\scripts\'\\")\\r\\ndf7 = pd.DataFrame({\'a\':[1,2,3],\'b\':[4,5,6]})\\r\\ndb.sql(\\"select current_setting(\'file_search_path\')\\").fetchone()[0]\\r\\n#%%\\r\\n\\r\\n\\r\\n\\r\\n#%%\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    with exp as (from Issued_Tree_Permits i\\r\\n    select\\r\\n        i.PERMIT_NUMBER,\\r\\n        i.TRUNK_DIAMETER,\\r\\n        unnest(regexp_extract_all(i.TRUNK_DIAMETER,\'\\\\d+([.]\\\\d+)?\'))::DOUBLE as trunk,\\r\\n    ),\\r\\n    tree_info as (\\r\\n        from exp e\\r\\n        select \\r\\n            e.PERMIT_NUMBER,\\r\\n            sum(e.trunk) as total_trees_diameter,\\r\\n            count() as tree_count\\r\\n        group by all\\r\\n    )\\r\\n    from Issued_Tree_Permits i\\r\\n        join tree_info t on t.PERMIT_NUMBER = i.PERMIT_NUMBER\\r\\n    select \\r\\n        t.total_trees_diameter, \\r\\n        t.tree_count,\\r\\n        i.*\\r\\n    order by\\r\\n        t.total_trees_diameter desc\\r\\n        \\r\\n        --regexp_replace(q.trunk,\'(\\\\d+([.]\\\\d)*)\',\'\'),\\r\\n    \\r\\n    \\"\\"\\")\\r\\n\\r\\n#%%\\r\\n\\r\\ndb.sql(\\r\\n    \\"\\"\\"--sql\\r\\n    from (VALUES \\r\\n            (1,2,3),\\r\\n            (4,4,5),\\r\\n            (4,4,5),\\r\\n            (4,4,5),\\r\\n            (4,4,5),\\r\\n        ) a(a,b,c)\\r\\n    \\r\\n    \\r\\n    \\"\\"\\")\\r\\n\\r\\n#%%\\r\\n\\r\\n\\r\\n\\r\\n#%%\\r\\nfrom dabbler.common import KeyFile\\r\\n# %%\\r\\nk = KeyFile()\\r\\n# %%\\r\\nprint(k.file.read_text())\\r\\n#%%\\r\\nimport sys\\r\\nsys.executable == \'c:\\\\\\\\Projects\\\\\\\\db_dabbler\\\\\\\\db_dabbler_env\\\\\\\\Scripts\\\\\\\\python.exe\'"}}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.server:Content length: 10526
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 10526\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/dabbler/lsp/db_data.py","languageId":"python","version":230,"text":"from filecmp import cmp\\r\\nfrom lsprotocol.types import (\\r\\n    CompletionItemKind,\\r\\n    MarkupContent,\\r\\n)\\r\\nfrom pathlib import Path\\r\\nfrom dabbler.lsp.sql_utils import CmpItem\\r\\nimport duckdb\\r\\nimport json\\r\\nfrom dabbler.common import check_name\\r\\n\\r\\n\\r\\n\\r\\nget_records_sql = \\"\\"\\"--sql\\r\\n    with\\r\\n        cols as (\\r\\n            select \\r\\n                database_name||\'.\'||schema_name as db_scm,\\r\\n                table_name, \\r\\n                list([column_name, data_type]) as cols\\r\\n            from duckdb_columns()\\r\\n            group by all\\r\\n        ),\\r\\n    tables_views as (\\r\\n        select \\r\\n            database_name||\'.\'||schema_name as db_scm,\\r\\n            table_name, \\r\\n            \'table\' as object_type,\\r\\n            \'table\' as table_type,\\r\\n            case\\r\\n                when not internal then sql\\r\\n                else null\\r\\n            end as sql\\r\\n        from duckdb_tables()\\r\\n        union all\\r\\n        select \\r\\n            database_name||\'.\'||schema_name as db_scm,\\r\\n            view_name, \\r\\n            \'table\' as object_type,\\r\\n            \'view\' as table_type,\\r\\n            case\\r\\n                when not internal then sql\\r\\n                else \'internal\'\\r\\n            end as sql\\r\\n        from duckdb_views()\\r\\n        union all\\r\\n            select distinct\\r\\n            database_name||\'.\'||schema_name as db_scm,\\r\\n            d.function_name,\\r\\n            \'table\' as object_type,\\r\\n            \'table_macro\',\\r\\n            case\\r\\n                when not internal then \'external\'\\r\\n                else \'internal\'\\r\\n            end as sql\\r\\n        from duckdb_functions() d\\r\\n        where d.function_type in (\'table\',\'table_macro\')\\r\\n            --and d.function_name not in (\'force_checkpoint\')\\r\\n        union all\\r\\n        select distinct\\r\\n            database_name||\'.\'||schema_name as db_scm,\\r\\n            d.function_name,\\r\\n            \'function\' as object_type,\\r\\n            d.function_type,\\r\\n            null,\\r\\n        from duckdb_functions() d\\r\\n        where d.function_type in (\'aggregate\',\'macro\',\'scalar\')\\r\\n            and d.function_name not similar to \'.*\\\\W.*\'\\r\\n            and not d.internal\\r\\n            and database_name != \'system\'\\r\\n        group by all\\r\\n        union all\\r\\n        select distinct\\r\\n            null,\\r\\n            d.function_name,\\r\\n            \'function\' as object_type,\\r\\n            d.function_type,\\r\\n            \'internal\',\\r\\n        from duckdb_functions() d\\r\\n        where d.function_type in (\'aggregate\',\'macro\',\'scalar\')\\r\\n            and d.function_name not similar to \'.*\\\\W.*\'\\r\\n            and database_name = \'system\'\\r\\n        group by all\\r\\n    )\\r\\n    select \\r\\n        t.*,\\r\\n        case when object_type = \'table\' then c.cols end as cols\\r\\n    from tables_views t\\r\\n        left join cols c using (db_scm, table_name)\\r\\n    \\"\\"\\"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ndef make_db(db_data:dict):\\r\\n    \\"\\"\\"\\r\\n    makes a duckdb in memory database from mirroring the tables \\r\\n    and columns in the IPython database.\\r\\n    \\r\\n    This DB is used by the language server to get column completion items\\r\\n    for subqueries and CTEs.\\r\\n    \\"\\"\\"\\r\\n    db2 = duckdb.connect()\\r\\n    databases = [x[0] for x in db2.execute(\\"select database_name from duckdb_databases()\\").fetchall()]\\r\\n\\r\\n    for db_to_add in db_data[\'databases\']:\\r\\n        if db_to_add not in databases:\\r\\n            db2.execute(f\\"attach \':memory:\' as {db_to_add}\\")\\r\\n\\r\\n    schemas = [x[0] for x in db2.execute(\\"select database_name ||\'.\'|| schema_name from duckdb_schemas()\\").fetchall()]\\r\\n\\r\\n    for schema in db_data[\'schemas\']:\\r\\n        if schema not in schemas:\\r\\n            db2.execute(f\\"create schema {schema}\\")\\r\\n            \\r\\n    db2.execute(f\\"use {db_data[\'current_schema\']};\\")\\r\\n    db2.execute(\'\\\\n\'.join([x[1] for x in db_data[\'dataframes\']]))\\r\\n\\r\\n    for schema, item, sql, cols in db_data[\'data\']:\\r\\n        if not cols:\\r\\n            continue\\r\\n        col_names = []\\r\\n        col_items = []\\r\\n        for c, d in cols:\\r\\n            if c in col_names:\\r\\n                continue\\r\\n            col_names.append(c)\\r\\n            col_items.append([c, d])\\r\\n\\r\\n        col_txt = \',\\\\n\'.join([f\'\\"{c[0]}\\" {c[1]}\' for c in col_items])\\r\\n        sql2 = f\'create table {check_name(item)}({col_txt})\'\\r\\n        db2.execute(f\'use {schema}; {sql2}\')\\r\\n\\r\\n    db2.execute(f\\"use {db_data[\'current_schema\']};\\")\\r\\n    if db_data[\'file_search_path\']:\\r\\n        db2.execute(f\\"\\"\\"set file_search_path to \'{db_data[\'file_search_path\']}\';\\"\\"\\")\\r\\n    \\r\\n    return db2\\r\\n\\r\\n\\r\\n\\r\\ndef make_completion_map(db:duckdb.DuckDBPyConnection,db_data):\\r\\n    \\"\\"\\"makes a map of completion items for the language server\\"\\"\\"\\r\\n    records = db.execute(get_records_sql).fetchall()\\r\\n    function_docs = json.loads(Path(__file__).parent.joinpath(\'functions.json\').read_text())\\r\\n    kind_map = {\\r\\n        \'table\':CompletionItemKind.File,\\r\\n        \'table_macro\':CompletionItemKind.File,\\r\\n        \'function\':CompletionItemKind.Function,\\r\\n    }\\r\\n\\r\\n    sort_map = {\\r\\n        \'table\':\\"2\\",\\r\\n        \'function\':\\"8\\"\\r\\n    }\\r\\n\\r\\n\\r\\n    item_map:dict[str,list[CmpItem]] = {}\\r\\n    item_map[\'root_namespace\'] = []\\r\\n\\r\\n    cur_db = db_data[\'current_schema\'].split(\'.\')[0]\\r\\n\\r\\n    for db_scm, fn_name, fn_type in db_data[\'functions\']:\\r\\n        if fn_type == \'table_macro\':\\r\\n            obj_type = \'table_macro\'\\r\\n        else:\\r\\n            obj_type = \'function\'\\r\\n\\r\\n        comp_item = CmpItem(\\r\\n                label=fn_name,\\r\\n                kind=kind_map[obj_type],\\r\\n                detail=None,\\r\\n                typ=\'function\',\\r\\n                sort=\'9\',\\r\\n                obj_type=obj_type,\\r\\n                doc=None)\\r\\n        if db_scm not in item_map:\\r\\n            item_map[db_scm] = []\\r\\n        item_map[db_scm].append(comp_item)\\r\\n\\r\\n\\r\\n    for db_scm, item, obj_type, comp_detial, sql, cols in records:\\r\\n\\r\\n        \\r\\n        item = check_name(item)\\r\\n\\r\\n        if not db_scm:\\r\\n            db_scm = \'root_namespace\'\\r\\n\\r\\n        db_schema_split = db_scm.split(\'.\')\\r\\n        if len(db_schema_split) == 2:\\r\\n            db, schema = db_schema_split\\r\\n        else:\\r\\n            db = \'aa\'\\r\\n            schema = \'aabb\'\\r\\n\\r\\n        if db_scm not in item_map:\\r\\n            item_map[db_scm] = []\\r\\n\\r\\n        if db == cur_db:\\r\\n            if schema not in item_map:\\r\\n                item_map[schema] = []\\r\\n        \\r\\n        fn_doc = None\\r\\n        fn_detail = None\\r\\n        \\r\\n        sort = sort_map[obj_type]\\r\\n        if sql == \'internal\':\\r\\n            sort = \'9\'\\r\\n        \\r\\n        if obj_type == \'function\' or comp_detial == \'table_macro\':\\r\\n            if item in function_docs:\\r\\n                fn_doc = MarkupContent(\\r\\n                    kind=\'markdown\',\\r\\n                    value=function_docs[item][\'documentation\'][\'documentation\']) \\r\\n                fn_detail = function_docs[item][\'documentation\'][\'detail\'] \\r\\n        \\r\\n        comp_item = CmpItem(\\r\\n                label=item,\\r\\n                kind=kind_map[obj_type],\\r\\n                detail=fn_detail,\\r\\n                typ=comp_detial,\\r\\n                sort=sort,\\r\\n                obj_type=obj_type,\\r\\n                doc=fn_doc)\\r\\n        \\r\\n\\r\\n        item_map[db_scm].append(comp_item)\\r\\n        if db == cur_db:\\r\\n            item_map[schema].append(comp_item)\\r\\n\\r\\n        if db_scm == db_data[\'current_schema\']:\\r\\n            item_map[\'root_namespace\'].append(comp_item)\\r\\n        \\r\\n        \\r\\n        if cols:\\r\\n            col_completions = [CmpItem(\\r\\n                label=c[0],\\r\\n                kind=CompletionItemKind.Field,\\r\\n                detail=None,\\r\\n                typ=c[1],\\r\\n                sort=\'1\',\\r\\n                obj_type=\'column\',\\r\\n                doc=None) for c in cols]\\r\\n            item_map[f\'{db_scm}.{item}\'] = col_completions\\r\\n            if db == cur_db:\\r\\n                item_map[f\'{schema}.{item}\'] = col_completions\\r\\n            if db_scm == db_data[\'current_schema\']:\\r\\n                if item in item_map:\\r\\n                    item_map[item].extend(col_completions)\\r\\n                else:\\r\\n                    item_map[item] = col_completions\\r\\n\\r\\n\\r\\n\\r\\n    for cat_schema in db_data[\'schemas\']:\\r\\n        cat, schema = cat_schema.split(\'.\')\\r\\n        cat_comp = CmpItem(\\r\\n            label=cat,\\r\\n            kind=CompletionItemKind.Folder,\\r\\n            detail=None,\\r\\n            typ=\'database\',\\r\\n            sort=\'3\',\\r\\n            obj_type=\'database\',\\r\\n            doc=None)\\r\\n        \\r\\n        schema_comp = CmpItem(\\r\\n            label=schema,\\r\\n            kind=CompletionItemKind.Folder,\\r\\n            detail=None,\\r\\n            typ=\'schema\',\\r\\n            sort=\'3\',\\r\\n            obj_type=\'schema\',\\r\\n            doc=None)\\r\\n        \\r\\n        if cat == cur_db:\\r\\n            if schema not in item_map and schema not in item_map[\'root_namespace\']:\\r\\n                if not cat_schema in item_map:\\r\\n                    item_map[cat_schema] = []\\r\\n                item_map[schema] = item_map[cat_schema]\\r\\n                item_map[\'root_namespace\'].append(schema_comp)\\r\\n\\r\\n        if cat not in item_map:\\r\\n            item_map[cat] = []\\r\\n            item_map[\'root_namespace\'].append(cat_comp)\\r\\n            \\r\\n        item_map[cat].append(schema_comp)\\r\\n        \\r\\n        root_labels = [x.label for x in item_map[\'root_namespace\']]\\r\\n        item_map[\'root_namespace\'].extend([x for x in item_map[\'system.main\'] if x.label not in root_labels])\\r\\n    \\r\\n    # for cat_schema in db_data[\'schemas\']:\\r\\n    #     cat, schema = cat_schema.split(\'.\')\\r\\n    #     if cat == cur_db:\\r\\n    #         if schema not in item_map and schema not in item_map[\'root_namespace\']:\\r\\n    #             if not cat_schema in item_map:\\r\\n    #                 item_map[cat_schema] = []\\r\\n    #             item_map[schema] = item_map[cat_schema]\\r\\n    #             item_map[\'root_namespace\'].append(schema_comp)\\r\\n    \\r\\n    return item_map\\r\\n\\r\\n\\r\\n        \\r\\n   "}}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.server:Content length: 8331
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 8331\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/dabbler/lsp/sql_utils.py","languageId":"python","version":1,"text":"#%%\\r\\nfrom dataclasses import dataclass\\r\\nfrom itertools import chain\\r\\nimport duckdb\\r\\nimport sqlparse\\r\\nimport re as regex\\r\\nfrom dabbler.common import check_name\\r\\n\\r\\nfrom lsprotocol.types import (\\r\\n    CompletionItem,\\r\\n    CompletionItemKind,\\r\\n    CompletionItemLabelDetails,\\r\\n)\\r\\n\\r\\n@dataclass\\r\\nclass SelectNode:\\r\\n    stmt:sqlparse.sql.Parenthesis\\r\\n    txt:str\\r\\n    length:int\\r\\n    start:int\\r\\n    end:int\\r\\n    cur_idx:int\\r\\n    \\r\\n\\r\\n@dataclass\\r\\nclass SqlStatement:\\r\\n    stmt:sqlparse.sql.Statement\\r\\n    length:int\\r\\n    start:int\\r\\n    end:int\\r\\n    txt:str\\r\\n    cur_idx:int\\r\\n    \\r\\n\\r\\n@dataclass\\r\\nclass SqlTxtRange:\\r\\n    txt:str\\r\\n    length:str\\r\\n    start:str\\r\\n    end:str\\r\\n    cur_idx:int\\r\\n\\r\\n\\r\\n@dataclass\\r\\nclass CmpItem:\\r\\n    label:str\\r\\n    kind:int\\r\\n    detail:str\\r\\n    typ:str\\r\\n    sort:str\\r\\n    obj_type:str\\r\\n    doc:str = None\\r\\n    \\r\\n    def __eq__(self, other) -> bool:\\r\\n        return self.label == other\\r\\n    \\r\\n    def __hash__(self) -> int:\\r\\n        return hash(self.label)\\r\\n    \\r\\n    def __repr__(self) -> str:\\r\\n        return self.label\\r\\n    \\r\\n    @property    \\r\\n    def comp(self):\\r\\n        if self.kind == CompletionItemKind.Keyword:\\r\\n            label = self.label\\r\\n        else:\\r\\n            label = label=check_name(self.label.strip(\'\\"\'))\\r\\n        \\r\\n        return CompletionItem(\\r\\n            label=label,\\r\\n            kind=self.kind,\\r\\n            sort_text=self.sort,\\r\\n            filter_text=self.label.lower(),\\r\\n            documentation=self.doc,\\r\\n            label_details=CompletionItemLabelDetails(\\r\\n                description=self.typ),\\r\\n                detail=self.detail,\\r\\n            )\\r\\n\\r\\n\\r\\ndef line_col(str, idx):\\r\\n    return str.count(\'\\\\n\', 0, idx) + 1, idx - str.rfind(\'\\\\n\', 0, idx)\\r\\n\\r\\n\\r\\ndef strip_sql_whitespace(txt):\\r\\n    txt = regex.sub(\'(.*)--sql.*\\\\n\',\'\\\\g<1>\',txt,flags=regex.IGNORECASE)\\r\\n    txt = regex.sub(\'\\\\s+\',\' \',txt,flags=regex.IGNORECASE)\\r\\n    return txt\\r\\n\\r\\n\\r\\nselect_node_words = [\\r\\n    \'select\',\\r\\n    \'from\',\\r\\n    \'pivot\',\\r\\n    \'unpivot\',\\r\\n]\\r\\n\\r\\nwhitespace_tokens = [\\r\\n    sqlparse.tokens.Newline,\\r\\n    sqlparse.tokens.Whitespace,\\r\\n]\\r\\n\\r\\n\\r\\ndef get_stmts(sql_txt,pos_in_doc):\\r\\n    stmts:list[SqlStatement] = []\\r\\n    \\r\\n    for x in sqlparse.parse(sql_txt):\\r\\n        \\r\\n        start=sql_txt.find(x.value)+pos_in_doc\\r\\n        length = len(x.value)\\r\\n        \\r\\n        stmt = SqlStatement(\\r\\n            stmt=x,\\r\\n            length=length,\\r\\n            start=start,\\r\\n            end=start+length,\\r\\n            txt=x.value,\\r\\n            cur_idx=pos_in_doc\\r\\n        )\\r\\n        \\r\\n        stmts.append(stmt)\\r\\n    return stmts\\r\\n\\r\\n\\r\\ndef get_statement(rng:SqlTxtRange,txt:str) -> SqlStatement:\\r\\n    \\r\\n    pos = rng.cur_idx\\r\\n    result = None\\r\\n    length = len(rng.txt)\\r\\n    \\r\\n    for stmt in sqlparse.parse(rng.txt):\\r\\n        \\r\\n        skipped = 0\\r\\n        pattern = \\"(create\\\\s+)(or\\\\s+replace\\\\s+)?(?P<type>view|table)\\\\s+(?P<name>\\\\w+)(\\\\s+as\\\\s+)(?P<select>.*)\\"\\r\\n        match = regex.search(pattern,stmt.value,regex.DOTALL | regex.IGNORECASE)\\r\\n        if match:\\r\\n            # print(match.group(\'select\'))\\r\\n            stmt = sqlparse.parse(match.group(\'select\'))[0]\\r\\n            skipped = match.span(\'select\')[0]\\r\\n            # print(stmt.value)\\r\\n        \\r\\n        s = rng.txt.find(stmt.value)+rng.start\\r\\n        e = s + len(stmt.value)\\r\\n        l = e - s\\r\\n        # print(txt[s:e])\\r\\n        # print(f\'pos:{pos} se:{s},{e}\')\\r\\n                \\r\\n        # print(pos,s,e)\\r\\n        if pos >= s and pos <= e and l <= length:\\r\\n            result = stmt\\r\\n            length = l\\r\\n            r_s, r_e, r_l = s,e,l\\r\\n            \\r\\n            \\r\\n    if result:\\r\\n        return SqlStatement(\\r\\n            stmt=stmt,\\r\\n            length=r_l,\\r\\n            start=r_s,\\r\\n            end=r_e,\\r\\n            txt=stmt.value,\\r\\n            cur_idx=rng.cur_idx\\r\\n        )\\r\\n\\r\\n\\r\\ndef get_selects(stmt):\\r\\n    tokens = [x for x in stmt.tokens]\\r\\n    for t in tokens:\\r\\n        if t.is_group:\\r\\n            tokens.extend(t.tokens)\\r\\n        if (t.value == \'(\' and \\r\\n            [x for x in t.parent.tokens if x.ttype not in whitespace_tokens][1].value.lower().split(\' \')[0] in select_node_words):\\r\\n            yield t.parent\\r\\n\\r\\n\\r\\n\\r\\ndef get_sel_node(stmt:SqlStatement,txt:str) -> SelectNode:\\r\\n        \\r\\n    pos = stmt.cur_idx\\r\\n    result = None\\r\\n    length = len(stmt.txt)\\r\\n    \\r\\n    for sel in get_selects(stmt.stmt):\\r\\n        s = stmt.txt.find(sel.value) + stmt.start\\r\\n        e = s + len(sel.value)\\r\\n        l = e-s\\r\\n        \\r\\n        # print(sel.value)\\r\\n        # print(txt[s:e])\\r\\n        # print(txt[pos-5:pos])\\r\\n        if pos >= s and pos <= e and l <= length:\\r\\n            result = sel\\r\\n            length = l\\r\\n            r_s, r_e, r_l = s,e,l\\r\\n            \\r\\n    if result:\\r\\n        return SelectNode(\\r\\n            stmt=sel,\\r\\n            length=r_l,\\r\\n            start=r_s,\\r\\n            end=r_e,\\r\\n            txt=result.value,\\r\\n            cur_idx=stmt.cur_idx\\r\\n        )\\r\\n    else:\\r\\n        return stmt\\r\\n\\r\\n\\r\\nre_patterns = [\\r\\n    # \'(?:\\"\\"\\"--sql[^\\\\n]*\\\\n)(?P<sql>.*?)(?:\\"\\"\\")\',\\r\\n    # \'([^\\\\n]*\\"\\"\\"--sql[^\\\\n]*\\\\n)(?P<sql>.*?)([\\\\n]*?\\"\\"\\")\',\\r\\n    \'([^\\\\n]*?\\"\\"\\"--sql[^\\\\n]*?\\\\n)(?P<sql>.*?)(\\"\\"\\")\',\\r\\n    # \'([^\\\\n]*?\\"\\"\\"--sql[^\\\\n]*?\\\\n)(?P<sql>.*?)([\\\\n]*?\\\\s*?\\"\\"\\")\',\\r\\n    \'(.(sql|execute|executemany)\\\\(\\")(?P<sql>.*?)(\\"\\\\s*(\\\\)|,))\',\\r\\n    \\"(.(sql|execute|executemany)\\\\(\')(?P<sql>.*?)(\'\\\\s*(\\\\)|,))\\",\\r\\n    ]\\r\\n\\r\\n\\r\\ndef get_idx(txt,cur_line,cur_col):\\r\\n    x = sum(len(x)+1 for i,x in enumerate(txt.split(\'\\\\n\'),start=0) if i < cur_line)\\r\\n    return x + cur_col\\r\\n\\r\\ndef get_range(txt,cur_line,cur_col):\\r\\n    # print(len(txt))\\r\\n    idx = get_idx(txt,cur_line,cur_col)\\r\\n    # print(idx)\\r\\n    re_matches = chain.from_iterable(\\r\\n        (regex.finditer(\\r\\n            pattern=p,\\r\\n            string=txt,\\r\\n            flags=regex.DOTALL | regex.IGNORECASE) for p in re_patterns)\\r\\n    )\\r\\n    \\r\\n    for m in re_matches:\\r\\n        s,e = m.span(\'sql\')\\r\\n        if idx >= s and idx <= e:\\r\\n            # print(f\'{s},{e}\\\\n\',m.groups()[0])\\r\\n            txt = m.group(\'sql\')\\r\\n            if not txt or len(txt.strip()) == 0:\\r\\n                return\\r\\n            # if txt.strip()[-1] != \';\':\\r\\n            #     txt += \';\'\\r\\n            \\r\\n            return SqlTxtRange(\\r\\n                txt=txt,\\r\\n                length=e-s,\\r\\n                start=s,\\r\\n                end=e,\\r\\n                cur_idx=idx\\r\\n            )\\r\\n\\r\\n\\r\\ndef get_sql2(txt,cur_line,cur_col) -> SelectNode:\\r\\n    \\r\\n    result = get_range(txt,cur_line,cur_col)\\r\\n    return result\\r\\n\\r\\ndef get_sql(txt,cur_line,cur_col) -> SelectNode:\\r\\n    \\r\\n    result = get_range(txt,cur_line,cur_col)\\r\\n    if not result:\\r\\n        return\\r\\n    \\r\\n    result = get_statement(result,txt)\\r\\n    if not result:\\r\\n        return\\r\\n    \\r\\n    sel_node = get_sel_node(result,txt)\\r\\n    \\r\\n    if not sel_node:\\r\\n        return result\\r\\n    \\r\\n    return sel_node\\r\\n\\r\\n\\r\\ndef left_of_cur_matches(line_txt:str,search_txt_list:list[str]):\\r\\n    return any([line_txt.lower()[-len(search_txt):] == search_txt for search_txt in search_txt_list])\\r\\n\\r\\n\\r\\n# table_predicates = [\'from \',\'join \',\'pivot \',\'unpivot \']\\r\\n\\r\\n\\r\\n# %%\\r\\n\\r\\n\\r\\n\\r\\ndef clean_partial_sql(txt):\\r\\n    \\r\\n    placeholder = (f\'placeholder{x}\' for x in range(2000))\\r\\n    \\r\\n    patterns = [\\r\\n        (\'(\\\\w+[.])([\\\\n\\\\s)])\',   f\'\\\\g<1>{next(placeholder)}\\\\g<2>\'),\\r\\n        (\'(\\\\(\\\\s*)(\\\\))\',         f\'\\\\g<1>{next(placeholder)}\\\\g<2>\'),\\r\\n        (\'(=[^\\\\n\\\\s]*$)\',         f\'\\\\g<1> {next(placeholder)}\'),\\r\\n        ]\\r\\n    \\r\\n    for pat, rep in patterns:\\r\\n        txt = regex.sub(pat,rep,txt,flags=regex.IGNORECASE)\\r\\n    return txt\\r\\n\\r\\n\\r\\n"}}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.server:Content length: 300
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 300\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py","version":849},"contentChanges":[{"range":{"start":{"line":10,"character":24},"end":{"line":10,"character":25}},"rangeLength":1,"text":""}]}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.protocol.json_rpc:Sending notification: 'textDocument/publishDiagnostics' PublishDiagnosticsParams(uri='file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py', diagnostics=[Diagnostic(range=11:1-11:2, message='Unexpected Token "CREATE"', severity=None, code=None, code_description=None, source='inline_sql', tags=None, related_information=None, data=None)], version=None)
INFO:pygls.protocol.json_rpc:Sending data: {"params": {"uri": "file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py", "diagnostics": [{"range": {"start": {"line": 11, "character": 1}, "end": {"line": 11, "character": 2}}, "message": "Unexpected Token \"CREATE\"", "source": "inline_sql"}]}, "method": "textDocument/publishDiagnostics", "jsonrpc": "2.0"}
DEBUG:pygls.server:Content length: 301
DEBUG:pygls.protocol.json_rpc:Received b'Content-Length: 301\r\n\r\n{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py","version":850},"contentChanges":[{"range":{"start":{"line":10,"character":24},"end":{"line":10,"character":24}},"rangeLength":0,"text":";"}]}}'
DEBUG:pygls.protocol.json_rpc:Notification message received.
DEBUG:pygls.protocol.json_rpc:Sending notification: 'textDocument/publishDiagnostics' PublishDiagnosticsParams(uri='file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py', diagnostics=[], version=None)
INFO:pygls.protocol.json_rpc:Sending data: {"params": {"uri": "file:///c%3A/Users/ryanw/python_projects/dabbler/dabbler/test_files/t2.py", "diagnostics": []}, "method": "textDocument/publishDiagnostics", "jsonrpc": "2.0"}
